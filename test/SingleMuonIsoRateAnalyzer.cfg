process PRODHLT  = {

#----------------- Input file -----------------------------------------
  source = PoolSource{
    untracked vstring fileNames ={ 'rfio:/castor/cern.ch/cms/store/mc/2007/1/26/mc-onsel-120_PU_Wmunu-DIGI-RECO-NoPU/0000/0091FA90-2AAE-DB11-AD4B-001560AD12EE.root' }
    #untracked int32 maxEvents = -1
    untracked int32 maxEvents = 100
  }

#------------ HLT Muon Path -------------------------------------------
  include "HLTrigger/Muon/data/PathSingleMu_2x1033_Iso.cff"
  path pSMIso = { singleMuIso }

#-- Lower all Pt thresholds down to at least the PtMin in the game ----
  # This must be set carefully:
  #   0) Locate all filters used in the path under study
  #      (for muons, the relevant files are "HLTrigger/Muon/data/Path....cff")
  #   1) For the L1 bits used in the HLTLevel1Seed filter set the thresholds 
  #      to the PtMin of the exercise (or lower if desired),
  #      as well as the appropriate prescale factors
  replace l1extraParticleMap.A_SingleMu14_thresh = 3.
  replace l1extraParticleMap.A_SingleMu14_prescale = 1
  #   2) Set Pt thresholds to at least PtMin for all relevant HLT filters
  #      (isolation filters do not have PT thresholds, so they do not count)
  replace SingleMuIsoL1Filtered.MinPt = 3.
  replace SingleMuIsoL2PreFiltered.MinPt = 3.
  replace SingleMuIsoL3PreFiltered.MinPt = 3.

#------------ Efficiency/Rate Analyzer --------------------------------
  module SingleMuonIsoRateAnalyzer = HLTMuonRateAnalyzer {
      # Generator source
      untracked InputTag GenLabel = VtxSmeared # use "source" in the future

      # L1 collection input tag 
      untracked InputTag L1CollectionLabel = SingleMuIsoL1Filtered

      # HLT collection input tags
      untracked VInputTag HLTCollectionLabels = {   
            SingleMuIsoL2PreFiltered, SingleMuIsoL2IsoFiltered
          , SingleMuIsoL3PreFiltered, SingleMuIsoL3IsoFiltered
      }  

      # Force decoupling from previous filter decision:
      # If 0: 
      #   this_filter_accepts_this_pt ==> previous_filter_must_accept_this_pt
      # If >0: 
      #   this_filter_accepts_this_pt ==> do_not_check_if_previous_filter_accepted_this_pt
      # Usual case: first element>0 => HLT decision decouples from L1
      #
      # Note: strictly speaking, there is never full decoupling. 
      #   Minimal Pt thresholds are always applied. So events not passing 
      #   these minimal Pt thresholds do not go through subsequent filters. 
      #   This is unavoidable due to the sequential logic of the HLT path.
      untracked vuint32 DecoupleFromPreviousFilters = { 0, 0, 0, 0 }
      #untracked vuint32 DecoupleFromPreviousFilters = { 1, 0, 0, 0 }

      # Shift to go to 90% efficiency pt values (in number of sigmas for 1/pt) 
      # ORCA values: 3.9 sigmas for L2; 2.2 sigmas for L3
      untracked vdouble NSigmas90 = { 3.9, 3.9, 2.2, 2.2 }

      # Number of objects passing thresholds (=2 for dimuon paths, for instance)
      untracked uint32 NumberOfObjects = 1

      # CrossSection (in nb) = generator cross section * filter efficiency
      untracked double CrossSection = 10.788

      # Luminosity (in 1/cm**2/s units)
      untracked double Luminosity = 1.e32

      # Parameters defining histogram limits and number of bins
      untracked double PtMin = 3.0
      untracked double PtMax = 70.0
      untracked uint32 Nbins = 67

      # Output Root file for histograms
      untracked string RootFileName = "SingleMuonIsoRateAnalyzer.root"
  }

#------------ Message Logger ------------------------------------------
   service = MessageLogger {
    untracked vstring destinations = { "cout" }
    untracked PSet cout = { untracked string threshold = "INFO" } 
    untracked vstring debugModules =  {  "SingleMuonIsoRateAnalyzer" }
   }

#------------ End path ------------------------------------------------
  endpath analyzerpath = { SingleMuonIsoRateAnalyzer }

}
